//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./com/us/openserver/protocols/keepalive/KeepAliveProtocol.java
//


#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/us/openserver/Level.h"
#include "com/us/openserver/protocols/BinaryReader.h"
#include "com/us/openserver/protocols/BinaryWriter.h"
#include "com/us/openserver/protocols/ProtocolBase.h"
#include "com/us/openserver/protocols/ProtocolConfiguration.h"
#include "com/us/openserver/protocols/keepalive/KeepAliveProtocol.h"
#include "com/us/openserver/protocols/keepalive/KeepAliveProtocolCommands.h"
#include "com/us/openserver/session/Session.h"
#include "java/io/IOException.h"
#include "java/lang/Exception.h"
#include "java/lang/Integer.h"
#include "java/util/concurrent/Executors.h"
#include "java/util/concurrent/ScheduledExecutorService.h"
#include "java/util/concurrent/ScheduledFuture.h"
#include "java/util/concurrent/TimeUnit.h"

@interface ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol () {
 @public
  id<JavaUtilConcurrentScheduledExecutorService> timer_;
}

@end

J2OBJC_FIELD_SETTER(ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol, timer_, id<JavaUtilConcurrentScheduledExecutorService>)

@implementation ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol

- (instancetype)init {
  ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol_init(self);
  return self;
}

- (void)initialize__WithComUsOpenserverSessionSession:(ComUsOpenserverSessionSession *)session
    withComUsOpenserverProtocolsProtocolConfiguration:(ComUsOpenserverProtocolsProtocolConfiguration *)pc
                                               withId:(id)userData {
  [super initialize__WithComUsOpenserverSessionSession:session withComUsOpenserverProtocolsProtocolConfiguration:pc withId:userData];
  @synchronized(self) {
    self->session_ = session;
    if (timer_ != nil) [timer_ shutdown];
    timer_ = JavaUtilConcurrentExecutors_newScheduledThreadPoolWithInt_(1);
    (void) [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(timer_)) scheduleAtFixedRateWithJavaLangRunnable:self withLong:ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol_INTERVAL withLong:ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol_INTERVAL withJavaUtilConcurrentTimeUnitEnum:JavaUtilConcurrentTimeUnitEnum_get_MILLISECONDS()];
  }
}

- (void)close {
  @synchronized(self) {
    if (timer_ != nil) [timer_ shutdown];
    ComUsOpenserverProtocolsBinaryWriter *bw = new_ComUsOpenserverProtocolsBinaryWriter_init();
    @try {
      [bw writeUInt16WithInt:ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol_PROTOCOL_IDENTIFIER];
      [bw writeWithInt:(jbyte) ComUsOpenserverProtocolsKeepaliveKeepAliveProtocolCommands_QUIT];
      @try {
        [((ComUsOpenserverSessionSession *) nil_chk(session_)) sendWithByteArray:[bw toByteArray]];
      }
      @catch (JavaIoIOException *ex) {
      }
      [self logWithComUsOpenserverLevelEnum:ComUsOpenserverLevelEnum_get_Debug() withNSString:@"Quit sent."];
    }
    @finally {
      @try {
        [bw close];
      }
      @catch (JavaIoIOException *ex) {
      }
    }
  }
}

- (void)dispose {
  @synchronized(self) {
    if (timer_ != nil) [timer_ shutdown];
  }
}

- (void)onPacketReceivedWithComUsOpenserverProtocolsBinaryReader:(ComUsOpenserverProtocolsBinaryReader *)br {
  jboolean dispose = NO;
  @synchronized(self) {
    if (session_ == nil) return;
    jint command = [((ComUsOpenserverProtocolsBinaryReader *) nil_chk(br)) read];
    switch (command) {
      case ComUsOpenserverProtocolsKeepaliveKeepAliveProtocolCommands_KEEP_ALIVE:
      [self logWithComUsOpenserverLevelEnum:ComUsOpenserverLevelEnum_get_Debug() withNSString:@"Received."];
      break;
      case ComUsOpenserverProtocolsKeepaliveKeepAliveProtocolCommands_QUIT:
      [self logWithComUsOpenserverLevelEnum:ComUsOpenserverLevelEnum_get_Info() withNSString:@"Quit received."];
      dispose = YES;
      break;
      default:
      [self logWithComUsOpenserverLevelEnum:ComUsOpenserverLevelEnum_get_Error() withNSString:NSString_formatWithNSString_withNSObjectArray_(@"Invalid or unsupported command.  Command: %1$s", [IOSObjectArray newArrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(command) } count:1 type:NSObject_class_()])];
      break;
    }
  }
  if (dispose) [((ComUsOpenserverSessionSession *) nil_chk(session_)) dispose];
}

- (void)logWithComUsOpenserverLevelEnum:(ComUsOpenserverLevelEnum *)level
                           withNSString:(NSString *)message {
  [((ComUsOpenserverSessionSession *) nil_chk(session_)) logWithComUsOpenserverLevelEnum:level withNSString:NSString_formatWithNSString_withNSObjectArray_(@"[Keep-Alive] %1$s", [IOSObjectArray newArrayWithObjects:(id[]){ message } count:1 type:NSObject_class_()])];
}

- (void)run {
  JavaLangException *connectionLostException = nil;
  @synchronized(self) {
    @try {
      ComUsOpenserverProtocolsBinaryWriter *bw = new_ComUsOpenserverProtocolsBinaryWriter_init();
      @try {
        [bw writeUInt16WithInt:ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol_PROTOCOL_IDENTIFIER];
        [bw writeWithInt:(jbyte) ComUsOpenserverProtocolsKeepaliveKeepAliveProtocolCommands_KEEP_ALIVE];
        [((ComUsOpenserverSessionSession *) nil_chk(session_)) sendWithByteArray:[bw toByteArray]];
        [self logWithComUsOpenserverLevelEnum:ComUsOpenserverLevelEnum_get_Debug() withNSString:@"Sent."];
      }
      @finally {
        @try {
          [bw close];
        }
        @catch (JavaIoIOException *ex) {
        }
      }
    }
    @catch (JavaLangException *ex) {
      [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(timer_)) shutdown];
      connectionLostException = ex;
    }
  }
  if (connectionLostException != nil) [((ComUsOpenserverSessionSession *) nil_chk(session_)) connectionLostWithJavaLangException:connectionLostException];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "KeepAliveProtocol", NULL, 0x1, NULL, NULL },
    { "initialize__WithComUsOpenserverSessionSession:withComUsOpenserverProtocolsProtocolConfiguration:withId:", "initialize", "V", 0x1, NULL, NULL },
    { "close", NULL, "V", 0x1, NULL, NULL },
    { "dispose", NULL, "V", 0x1, NULL, NULL },
    { "onPacketReceivedWithComUsOpenserverProtocolsBinaryReader:", "onPacketReceived", "V", 0x1, NULL, NULL },
    { "logWithComUsOpenserverLevelEnum:withNSString:", "log", "V", 0x4, NULL, NULL },
    { "run", NULL, "V", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "PROTOCOL_IDENTIFIER_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol_PROTOCOL_IDENTIFIER },
    { "INTERVAL_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol_INTERVAL },
    { "timer_", NULL, 0x2, "Ljava.util.concurrent.ScheduledExecutorService;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol = { 2, "KeepAliveProtocol", "com.us.openserver.protocols.keepalive", NULL, 0x1, 7, methods, 3, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol;
}

@end

void ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol_init(ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol *self) {
  (void) ComUsOpenserverProtocolsProtocolBase_init(self);
}

ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol *new_ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol_init() {
  ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol *self = [ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol alloc];
  ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComUsOpenserverProtocolsKeepaliveKeepAliveProtocol)
